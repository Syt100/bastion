//! Doc generator for keeping docs in sync with the actual CLI definition.
//!
//! This intentionally lives in the `bastion` package so it can reuse the real clap command tree.

use std::path::{Path, PathBuf};

use anyhow::Context as _;
use clap::CommandFactory as _;

#[path = "../config.rs"]
#[allow(dead_code)]
mod config;
#[path = "../i18n/mod.rs"]
#[allow(dead_code)]
mod i18n;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum Mode {
    Check,
    Write,
}

fn main() -> Result<(), anyhow::Error> {
    let mode = parse_mode(std::env::args().skip(1))?;

    let root = repo_root()?;

    let en = render_cli_reference(i18n::cli::CliLocale::EnUs)?;
    let zh = render_cli_reference(i18n::cli::CliLocale::ZhCn)?;

    // Enforce translation completeness in all modes (local dev should see it early too).
    if !zh.missing_translation_keys.is_empty() {
        anyhow::bail!(
            "missing zh-CN CLI translation keys ({}):\n{}",
            zh.missing_translation_keys.len(),
            zh.missing_translation_keys
                .iter()
                .map(|k| format!("- {k}"))
                .collect::<Vec<_>>()
                .join("\n")
        );
    }

    let en_path = root.join("docs/user/reference/cli.generated.md");
    let zh_path = root.join("docs/zh/user/reference/cli.generated.md");

    match mode {
        Mode::Write => {
            write_file(&en_path, &en.markdown)?;
            write_file(&zh_path, &zh.markdown)?;
        }
        Mode::Check => {
            check_file(&en_path, &en.markdown)?;
            check_file(&zh_path, &zh.markdown)?;
        }
    }

    Ok(())
}

fn parse_mode<I>(args: I) -> Result<Mode, anyhow::Error>
where
    I: IntoIterator<Item = String>,
{
    let mut mode = Mode::Check;
    for arg in args {
        match arg.as_str() {
            "--check" => mode = Mode::Check,
            "--write" => mode = Mode::Write,
            "-h" | "--help" => {
                println!(
                    "Usage: cargo run -p bastion --bin docgen -- [--check|--write]\n\
\n\
Options:\n\
  --check   Verify generated docs are up-to-date (default)\n\
  --write   Write generated docs to the repository\n"
                );
                std::process::exit(0);
            }
            other => anyhow::bail!("unknown arg: {other} (try --help)"),
        }
    }
    Ok(mode)
}

fn repo_root() -> Result<PathBuf, anyhow::Error> {
    let crate_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    crate_dir
        .parent()
        .and_then(|p| p.parent())
        .map(|p| p.to_path_buf())
        .context("failed to resolve repo root from CARGO_MANIFEST_DIR")
}

struct RenderedReference {
    markdown: String,
    missing_translation_keys: Vec<String>,
}

fn render_cli_reference(locale: i18n::cli::CliLocale) -> Result<RenderedReference, anyhow::Error> {
    let mut cmd = i18n::cli::localize_command(config::Cli::command(), locale);
    cmd = set_term_width_recursive(cmd, 0);
    cmd.build();

    let missing_translation_keys = if locale == i18n::cli::CliLocale::ZhCn {
        i18n::cli::missing_zh_translation_keys(&cmd)
            .into_iter()
            .collect::<Vec<_>>()
    } else {
        Vec::new()
    };

    let mut out = String::new();
    out.push_str(
        "<!-- This file is @generated by `cargo run -p bastion --bin docgen -- --write` -->\n",
    );
    out.push_str("<!-- Do not edit manually. -->\n\n");

    render_command_tree(&cmd, &mut out)?;

    Ok(RenderedReference {
        markdown: out,
        missing_translation_keys,
    })
}

fn render_command_tree(cmd: &clap::Command, out: &mut String) -> Result<(), anyhow::Error> {
    let title = cmd
        .get_bin_name()
        .map(|s| s.to_string())
        .unwrap_or_else(|| cmd.get_name().to_string());

    out.push_str(&format!("## {title}\n\n"));
    out.push_str("```text\n");
    let mut render_cmd = cmd.clone();
    out.push_str(&render_cmd.render_long_help().to_string());
    if !out.ends_with('\n') {
        out.push('\n');
    }
    out.push_str("```\n\n");

    for sub in cmd.get_subcommands() {
        if sub.is_hide_set() {
            continue;
        }
        render_command_tree(sub, out)?;
    }

    Ok(())
}

fn set_term_width_recursive(cmd: clap::Command, width: usize) -> clap::Command {
    cmd.term_width(width)
        .mut_subcommands(|sub| set_term_width_recursive(sub, width))
}

fn write_file(path: &Path, contents: &str) -> Result<(), anyhow::Error> {
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent)
            .with_context(|| format!("create dir {}", parent.display()))?;
    }
    std::fs::write(path, contents).with_context(|| format!("write {}", path.display()))
}

fn check_file(path: &Path, contents: &str) -> Result<(), anyhow::Error> {
    let current = std::fs::read_to_string(path)
        .with_context(|| format!("read {}", path.display()))
        .unwrap_or_default();
    if current != contents {
        anyhow::bail!(
            "generated docs out of date: {}\n\
run: cargo run -p bastion --bin docgen -- --write",
            path.display()
        );
    }
    Ok(())
}
